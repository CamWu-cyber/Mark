# 887.鸡蛋掉落
你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

##### 示例1
    输入：K = 1, N = 2
    输出：2
    解释：
    鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
    否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
    如果它没碎，那么我们肯定知道 F = 2 。
    因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。

##### 示例2
    输入：K = 2, N = 6
    输出：3

##### 示例3
    输入：K = 3, N = 14
    输出：4

思路：此题表面上是构建二维dp，但是千万不要往那方面想。想象一栋楼，从第i层仍鸡蛋，如果鸡蛋碎了，就应该往楼下找，如果鸡蛋没碎，应该往楼上找。

1.dp[k][m]=n k个鸡蛋，仍m次，在这种情况下，能测试出的楼层数为n，所以当n==N时，就找到了最佳的m值。

2.状态转移：dp[k][m] = dp[k][m-1]+dp[k-1][m-1]+1，总楼层数=楼上的楼层数+楼下的楼层数+1（当前这层）

3.base case: 第一行，第一列都为0，因为鸡蛋数k为0，尝试次数m为0时，能测数出的楼层数肯定为0

    #!/usr/bin/python
    class Solution:
        def superEggDrop(self, K, N):
            dp = [[0]*(N+1)for i in range(K+1)]
            for j in range(N+1):
                dp[0][j] = 0
            for i in range(K+1):
                dp[i][0] = 0
            m = 0
            # 最坏的情况下，肯定会用掉所有的鸡蛋，所以是大写K
            while dp[K][m] < N:
                m += 1
                for k in range(1, K+1):
                    dp[k][m] = dp[k][m-1]+dp[k-1][m-1]+1
            return m

    if __name__ == '__main__':
        obj = Solution()
        print(obj.superEggDrop(1,2))
        print(obj.superEggDrop(2,6))
        print(obj.superEggDrop(3,14))

#### 运行结果
    2
    3
    4
