# 300. 最长递增子序列
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

##### 示例1
    输入：nums = [10,9,2,5,3,7,101,18]
    输出：4
    解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

#### 示例2
    输入：nums = [0,1,0,3,2,3]
    输出：4
   
思路：此题需要注意，子序列是可以跳着选的，不一定是连续的。一维dp，指针i每往前移动一步，i内部的元素挨个比较，如果是递增的就加1，否则跳过。

1.dp[i]：以nums[i]结尾的最长递增子序列长度

2.状态转移：dp[i] = max(dp[i] ,dp[j]+1)

3.base case；dp初始化都为1，表示至少包含自己的长度

4.时间复杂度较高 o(n**2)

    #!/usr/bin/python
    class Solution:
        def lengthOfLIS(self, nums):
            # dp[i]：以nums[i]结尾的最长递增子序列长度
            # 状态转移：dp[i] = max(dp[i] ,dp[j]+1)
            # base case；dp初始化都为1，表示至少包含自己的长度
            # 指针i每往前移动一步，i内部的元素挨个比较，如果是递增的就加1，否则跳过
            # 时间复杂度较高 o(n**2)
            if not nums:
                return 0
            n = len(nums)
            dp = [1]*n
            for i in range(1, n):
                for j in range(i):
                    if nums[j] < nums[i]:
                        dp[i] = max(dp[i] ,dp[j]+1)
            return max(dp)

    if __name__ == '__main__':
      obj = Solution()
      print(obj.lengthOfLIS([10,9,2,5,3,7,101,18]))
      print(obj.lengthOfLIS([0,1,0,3,2,3]))
 
 #### 运行结果
     4
     4
