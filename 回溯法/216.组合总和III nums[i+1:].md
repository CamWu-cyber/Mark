# 216.组合总和 III
找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：
所有数字都是正整数。
解集不能包含重复的组合

##### 示例1:
    输入: k = 3, n = 7
    输出: [[1,2,4]]
    
##### 示例2
    输入: k = 3, n = 9
    输出: [[1,2,6], [1,3,5], [2,3,4]]

思路：回溯框架，path表示路径，nums表示需要挨个去试的数字，每次递归传入nums[i+1:]表示不重复选择。

    #!/usr/bin/python
    class Solution:
        def combinationSum3(self, k, n):
            def backtrack(path, nums):
                if len(path) == k and sum(path) == n:
                    res.append(path[:])
                    return None
                for i in range(len(nums)):
                    path.append(nums[i])
                    backtrack(path, nums[i+1:])
                    path.pop()
            res = []
            path = []
            nums = [i for i in range(1, 10)]
            backtrack(path, nums)
            return res

    if __name__ == '__main__':
        obj = Solution()
        print(obj.combinationSum3(3,7))
        print(obj.combinationSum3(3,9))
            
#### 运行结果
    [[1, 2, 4]]
    [[1, 2, 6], [1, 3, 5], [2, 3, 4]]
####

### C++

1. 确定递归函数参数

* result：存放结果集
* path: 存放符合条件的结果
* n（int）目标和，也就是题目中的n。
* k（int）就是题目中要求k个数的集合。
* sum（int）为已经收集的元素的总和，也就是path里元素的总和。
* startIndex（int）为下一层for循环搜索的起始位置。

2. 确定终止条件

在上面已经说了，k其实就已经限制树的深度，因为就取k个元素，树再往下深了没有意义。

所以如果path.size() 和 k相等了，就终止。

如果此时path里收集到的元素和（sum） 和n（就是题目描述的n）相同了，就用result收集当前的结果。

所以 终止代码如下：

    if (path.size() == k) {
        if (sum == targetSum) result.push_back(path);
        return; // 如果path.size() == k 但sum != targetSum 直接返回
    }
    
3. 单层搜索过程

本题和 77. 组合 区别之一就是集合固定的就是9个数[1,...,9]，所以for循环固定i<=9

处理过程就是 path收集每次选取的元素，相当于树型结构里的边，sum来统计path里元素的总和。

别忘了处理过程 和 回溯过程是一一对应的，处理有加，回溯就要有减！

