# 101.对称二叉树
给定一个二叉树，检查它是否是镜像对称的。

思路：检查root.left.left == root.right.right和root.left.right == root.right.left, 写递归的时候需要注意，因为参数不允许root.left.left这种形式传递，所以需要提前用变量接住root.left。

    #!/usr/bin/python
    class TreeNode:
        def __init__(self, val):
            self.val = val
            self.left = None
            self.right = None


    class Solution:
        def inittree(self, list, root, i):
            if i < len(list):
                root = TreeNode(list[i])
                root.left = self.inittree(list, root.left, 2 * i + 1)
                root.right = self.inittree(list, root.right, 2 * i + 2)
            return root

        def isSymmetric(self, root):
            if not root:
                return True
            left = root.left
            right = root.right
            # 方法里面套方法，也可以把方法写在外面
            def isMirror(left, right):
                if not left and not right:
                    return True
                if not left or not right:
                    return False
                if left.val != right.val:
                    return False
                return isMirror(left.left, right.right) and isMirror(left.right, right.left)
            return isMirror(root.left, root.right)

        def inorder(self, root):
            if not root:
                return []
            return self.inorder(root.left) + [root.val] + self.inorder(root.right)

    if __name__ == '__main__':
        a = [1, 2, 2, None, 3, None, 3]
        obj = Solution()
        root = obj.inittree(a, None, 0)
        print(obj.inorder(root))
        print(obj.isSymmetric(root))

#### 运行结果
    Flase
