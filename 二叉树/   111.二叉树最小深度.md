# 111. 二叉树最小深度
给定一个二叉树，找出其最小深度。

思路：左右子树中最小的加1

P.S.: 此题出现了list中None占位的情况，需要特殊处理（见minDepth()）

    class TreeNode:
      def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

    class Solution:
      def createTree(self, list, root, i):
        if i < len(list):
          root = TreeNode(list[i])
          root.left = self.createTree(list, root.left, i*2+1)
          root.right = self.createTree(list, root.right, i*2+2)
        return root

      # 左右子树中最小的加1
      def minDepth(self, root):
        if not root:
          return 0
        # 左右子树为空的节点也要考虑进去，因为输入的时候None是被算进去的
        if not root.left and not root.right:
          return 0
        left = self.minDepth(root.left)
        right = self.minDepth(root.right)
        return min(left, right)+1

      def inorder(self, root):
        if not root:
          return []
        return self.inorder(root.left)+[root.val]+self.inorder(root.right)

    if __name__ == '__main__':
        a = [3,9,20,None,None,15,7]
        obj = Solution()
        root = obj.createTree(a, None, 0)
        print(obj.inorder(root))
        print(obj.minDepth(root))

#### 运行结果
    [None, 9, None, 3, 15, 20, 7]
    2
